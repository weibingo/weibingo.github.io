<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BIG DATA探索者,经济迷,浅度摄影,爱好历史,对社会意识,人文感兴趣"><meta name="keywords" content=""><meta name="author" content="weibingo"><meta name="copyright" content="weibingo"><title>BIG DATA探索者,经济迷,历史,人文 | WBINGのBLOG</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.8.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"3FYJCLGPHO","apiKey":"d730ef95ff5ff79a19b74363531c066b","indexName":"prod_weibing-blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://hexo-1256892004.cos.ap-beijing.myqcloud.com/page/avatar.jpg"></div><div class="author-info__name text-center">weibingo</div><div class="author-info__description text-center">BIG DATA探索者,经济迷,浅度摄影,爱好历史,对社会意识,人文感兴趣</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/weibingo">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">52</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">43</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">21</span></a></div></div></div><nav id="nav" style="background-image: url(https://hexo-1256892004.cos.ap-beijing.myqcloud.com/page/top.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">WBINGのBLOG</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="site-info"><div id="site-title">WBINGのBLOG</div><div id="site-sub-title">BIG DATA探索者,经济迷,历史,人文</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/weibingo" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fa"></i></a><a class="social-icon" href="https://www.jianshu.com/u/0352716a8f7d" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-book fa"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/article/GRPC%E5%BA%95%E5%B1%82%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-HTTP%20Trailer.html">GRPC底层传输协议-HTTP Trailer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-03-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/RPC/">RPC</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/RPC/">RPC</a></span><div class="content"><p>从上一篇文章，我们知道grpc使用HTTP&#x2F;2作为底层传输协议，并且在响应消息包含 3 个主要部分：响应头信息、以长度作为前缀的消息以及 trailer。那么什么是trailer呢？大家很多人前端或者后端工作中都在使用http协议，但我咨询了一些同事，都没听过http trailer，包括没在使用grpc的自己。</p>
<h2 id="什么是Trailer-HTTP-标头？"><a href="#什么是Trailer-HTTP-标头？" class="headerlink" title="什么是Trailer HTTP 标头？"></a>什么是Trailer HTTP 标头？</h2><p>Trailer HTTP 标头是一个响应标头，指示使用分块传输编码编码的消息的标头中是否存在一组指定的标头字段。它使发送者能够在分块消息的末尾放置附加字段以传递元数据。分块传输编码是 HTTP 版本 1.1 中包含的一种数据传输技术。要启用Trailer HTTP 标头中的trailer 字段，必须将TE 请求标头设置为trailers。用户代理准备接受的传输编码在 TE 请求标头中指定。Trailer HTTP 标头只有一个值。Trailer HTTP 标头语法是 header-name，它是在使用分块传输编码编码的消息预告片中找到的标头字段的集合。Trailer HTTP 标头的示例如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Trailer: Expires</span><br><span class="line">7\r\n</span><br><span class="line">Mozilla\r\n</span><br><span class="line">9\r\n</span><br><span class="line">Developer\r\n</span><br><span class="line">7\r\n</span><br><span class="line">Network\r\n</span><br><span class="line">0\r\n</span><br><span class="line">Expires: Wed, 21 Oct 2015 07:28:00 GMT\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h3 id="Trailer-HTTP-标头的语法是什么？"><a href="#Trailer-HTTP-标头的语法是什么？" class="headerlink" title="Trailer HTTP 标头的语法是什么？"></a>Trailer HTTP 标头的语法是什么？</h3><p>Trailer HTTP 标头的语法是标头名称。使用 Trailer HTTP 标头的语法如下。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trailer: header-names</span><br></pre></td></tr></table></figure></div><a class="more" href="/article/GRPC%E5%BA%95%E5%B1%82%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-HTTP%20Trailer.html#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/article/GRPC%E5%BA%95%E5%B1%82%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE.html">GRPC底层传输协议</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-03-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/RPC/">RPC</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/RPC/">RPC</a></span><div class="content"><p>‍</p>
<p>Grpc他是由谷歌开发，其中主要有以下特点：</p>
<ol>
<li><strong>高性能</strong> ：gRPC 使用基于二进制的协议，并采用 Protocol Buffers 进行高效的消息序列化和反序列化。它使用 HTTP&#x2F;2 作为底层传输协议，支持多路复用、头部压缩和流等特性，提供了更低的延迟和更高的吞吐量。</li>
<li><strong>跨语言支持</strong> ：gRPC 提供了多种编程语言的支持，如 C++, <strong>Java</strong>, <strong>Python</strong>, Go 等。通过使用 Protocol Buffers 的接口描述语言，可以自动生成客户端和服务端的代码，提供了更好的类型安全性和编译时检查。</li>
</ol>
<p>其中使用 HTTP&#x2F;2作为底层传输协议，然后我们使用proto文件生成的Java或者python代码进行服务提供者和客户端调用。那么他内部协议设计是怎样的呢？</p>
<p>在 HTTP&#x2F;2 中，客户端和服务器端的所有通信都是通过一个 TCP 连接完成的，这个连接可以传送任意数量的双向字节流。</p>
<p>相关术语如下：</p>
<p>流（stream）：在一个已建立的连接上的双向字节流。一个流可以携带一条或多条消息。<br>帧（frame）：HTTP&#x2F;2 中最小的通信单元。每一帧都包含一个帧头，它至少要标记该帧所属的流。<br>消息（message）：完整的帧序列，映射为一条逻辑上的 HTTP 消息，由一帧或多帧组成。这样的话，允许消息进行多路复 用，客户端和服务器端能够将消息分解成独立的帧，交叉发送 它们，然后在另一端进行重新组合。<br>如图所示，gRPC 通道代表一个到端点的连接，也就是一个 HTTP&#x2F;2 连接。当客户端应用程序创建 gRPC 通道的时候，它会在幕后创建一个到服务器端的 HTTP&#x2F;2 连接。在通道创建完成之后，就可以重用它来发送多个到服务器端的远程调用。这些远程调用会映射为 HTTP&#x2F;2 中的 流。远程调用中的消息以 HTTP&#x2F;2 帧的形式进行发送，帧可能会携带一 条 gRPC 长度前缀的消息，也可能在 gRPC 消息非常大的情况下，一条消息跨多帧。</p>
<p><img src="/assets/image-20240306163354-pi5tzaj.png" alt="image">​</p>
<ol>
<li><h2 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h2> 请求消息用于初始化远程调用。在 gRPC 中，请求消息始终由客户端应用程序来触发，它包含 3 部分：</li>
</ol>
<p>请求头信息<br>以长度作为前缀的消息<br>流结束标记（end of stream flag，以下简称 EOS 标记），<br>如图所示。远程调用在客户端发送请求头信息之后就会初始化，然后其中会发送以长度作为前缀的消息，最后发送 EOS 标记，通知收件方请求消息已发送。</p></div><a class="more" href="/article/GRPC%E5%BA%95%E5%B1%82%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE.html#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/article/%E9%A3%9E%E6%A1%A8%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E6%8A%80%E6%9C%AF.html">飞桨大模型分布式训练技术</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-03-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AI%E5%B7%A5%E7%A8%8B/">AI工程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/">大模型</a></span><div class="content"><h2 id="1-背景与挑战"><a href="#1-背景与挑战" class="headerlink" title="1. 背景与挑战"></a><strong>1. 背景与挑战</strong></h2><p>近年来，大模型由于良好的模型效果和广阔的应用前景，逐渐受到业界的广泛重视。主流的 AI 科技公司也站在了大模型研究的前沿，模型参数量的规模呈现快速增长的趋势。从 2018 年 1 亿参数规模的模型增长至今已达千亿参数量规模。</p>
<p><img src="https://pic2.zhimg.com/80/v2-b4239300325f244662e9226db5ce3621_1440w.webp">​</p>
<p>大模型的出现给模型训练带来极大的挑战。即使使用 A800、H800 这样的 GPU，单张 GPU 的算力和显存都是远远无法满足大模型训练需求的。为了保证大模型可训练，并提高整体训练吞吐，需要用到模型并行 + 数据并行等技术。</p>
<p><img src="https://pic1.zhimg.com/80/v2-370e442b343281615934289b819a31b0_1440w.webp">​</p>
<p>这张图展示的是大模型分布式训练技术的发展历程。</p>
<p>对于十亿及以下的模型，单卡往往就能放下全量模型参数和梯度，传统的数据并行即可即可覆盖其应用场景。当模型规模到了百亿量级以后，需要使用分组参数切片的方式将模型参数、梯度和优化器状态切分到各个卡上，保证单机可放下。当模型规模到了千亿以后，则需要同时使用模型并行、数据并行等多种并行技术混合进行高效训练。在这个阶段里，分布式并行技术从单一的基础并行策略演进为多种并行策略的组合。</p>
<p>当模型规模到了万亿级别以后，稠密模型已经难以高效训练，从而衍生出稀疏专家模型，也伴随着 MoE 等并行策略的演进与迭代。</p>
<p>下面，我将为大家介绍飞桨在大模型训练领域的特色分布式训练技术。</p></div><a class="more" href="/article/%E9%A3%9E%E6%A1%A8%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E6%8A%80%E6%9C%AF.html#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/article/%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2%E5%9C%A8%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E6%8A%80%E6%9C%AF%E5%92%8C%E5%AE%9E%E8%B7%B5.html">向量检索在大模型应用场景的技术和实践</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-02-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AI%E5%B7%A5%E7%A8%8B/">AI工程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/">大模型</a></span><div class="content"><h2 id="1-向量检索应用简介"><a href="#1-向量检索应用简介" class="headerlink" title="1. 向量检索应用简介"></a><strong>1. 向量检索应用简介</strong></h2><p>向量是多维数学空间里的一个点，在各维度上的坐标的一串数字。这个点就是来源于真实世界的物体进行数字化之后在数学空间的投影。那么不同点之间有一个数学关系，就是距离，距离远近就代表两个物体的相似程度。</p>
<p><img src="https://pic2.zhimg.com/80/v2-079f2bae4f4cdf18eef001bf28346ff9_1440w.webp">​</p>
<p>非结构化数据转换成向量的过程称为 embedding。通过深度学习的训练，可以将真实世界数字化后的离散特征提取出来，投影到数学空间上，成为一个数学意义上的向量，同时很神奇的保留着通过向量之间的距离表示语义相似度的能力，这就是 embedding 的效果。</p>
<p><img src="https://pic1.zhimg.com/80/v2-58a3f141371d4a0d7a1e71b342f4e1a0_1440w.webp">​</p>
<p>在大语言模型出现之前（2020 年以前），向量检索这项技术就已经发展成熟。随着深度学习的技术，广泛应用于图片、音频、视频的搜索和推荐、人脸识别、语音识别等传统人工智能应用领域。</p>
<p><img src="https://pic3.zhimg.com/80/v2-e66cf3f6ebf1a558ac6028b28a7610f6_1440w.webp">​</p>
<p>大模型的出现改变了人机交互方式，带来了人工智能技术的新革命，一下子火起来，进入了一个大模型的时代。当然现在处于初期阶段，在实际应用上还存在很多问题。</p></div><a class="more" href="/article/%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2%E5%9C%A8%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E6%8A%80%E6%9C%AF%E5%92%8C%E5%AE%9E%E8%B7%B5.html#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/article/LMOps%E5%B7%A5%E5%85%B7%E9%93%BE%E4%B8%8E%E5%8D%83%E5%B8%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0.html">LMOps工具链与千帆大模型平台</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-12-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AI%E5%B7%A5%E7%A8%8B/">AI工程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/">大模型</a></span><div class="content"><h2 id="1-从机器学习到百模大战"><a href="#1-从机器学习到百模大战" class="headerlink" title="1. 从机器学习到百模大战"></a><strong>1. 从机器学习到百模大战</strong></h2><p>众所周知，目前我们实现人工智能的主要技术手段是机器学习技术，特别是其中基于深层神经网络的深度学习技术。机器学习的本质是通过具有学习能力的算法、对数据进行建模的技术。深度学习借助大规模的算力解决了机器学习中特征表示的人工干预的瓶颈，在效果上取得了巨大突破。因此，机器学习成为目前人工智能的主流技术。</p>
<p>深度学习和生成式大模型之间的关系，如下图右侧所示，在 2012 年至 2016 年左右，像卷积神经网络、对抗生成网络、ResNet 等经典的深度学习模型，已经在计算视觉、语音识别、自然语言处理等领域取得了显著的效果提升。这些经典深度学习模型既有判别式、也有生成式，它们往往会在 ImageNet、COCO 等有标注的数据集上进行预训练，形成带有预训练权重、可以进一步进行 Fine-tuning 的预训练模型。</p>
<p>在 2017 年之后，Transformer 结构在自然语言处理领域首先被成功应用，在这之后以 Transformer 为基础组件的生成式大模型逐步成为视觉、自然语言处理、跨模态理解和生成领域的主流技术。这类技术通常以 Transformer 和注意力机制作为组件，并且它可以并行地进行自监督学习，参数规模在十亿以上。其中，将生成式大模型技术应用在语言建模上的方式，被称为「大语言模型」。在经过进一步的调优之后，形成了像 ChatGPT、文心一言等被大家熟知的对话式、生成式大语言模型应用。</p>
<p><img src="https://pic4.zhimg.com/80/v2-3b9525d6fccbf0b6451f7e4dab491127_1440w.webp">​</p>
<p>在过去的半年，我们经历了一场百模大战。尤其是在开源社区，新的大模型如雨后春笋般涌现，而大模型相关的技术也越来越标准化、同质化。在这里为大家分享一个小故事。我们可以在大模型中了解到很多「驼」系英语词汇，比如 Llama 是美洲驼，Alpaca 是羊驼，Vicuna 是小羊驼。</p>
<p>为什么有那么多以「驼」命名的大语言模型？因为大语言模型 Large Language Model 的缩写是 LLM，2 个 L 放在一起不方便读出来，Meta 公司为了方便大家记忆，所以选了相近的词语 Llama（美洲驼）。后来很多基于 Llama 开源模型进行调优和构建的大语言模型，都以「驼」系的名称命名。</p>
<p>如下图所示，我们可以看到在硅谷的大模型创业公司中，除 OpenAI 外，目前已有将近 1&#x2F;3 的资金投入了 MLOps 和 LMOps 相关的平台和工具方向。接下来，我将为大家详细拆解，在百模大战的背后，为什么 MLOps 和 LMOps 平台和工具能够获得资本的青睐。</p>
<p><img src="https://pic3.zhimg.com/80/v2-5135d2f5a771ab5ccbf1639e579cd8d6_1440w.webp">​</p>
<p>首先看看大模型在技术和应用层面带来了哪些变化。比如在以下 4 个技术层面：</p></div><a class="more" href="/article/LMOps%E5%B7%A5%E5%85%B7%E9%93%BE%E4%B8%8E%E5%8D%83%E5%B8%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0.html#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/article/%E5%A4%A7%E8%A7%84%E6%A8%A1AI%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5.html">大规模AI高性能网络的设计与实践</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-12-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AI%E5%B7%A5%E7%A8%8B/">AI工程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/">大模型</a></span><div class="content"><h2 id="1-大模型训练对网络的要求"><a href="#1-大模型训练对网络的要求" class="headerlink" title="1. 大模型训练对网络的要求"></a><strong>1. 大模型训练对网络的要求</strong></h2><p>我们先来聊聊大模型训练对网络的需求。</p>
<p>最近半年以来大模型持续火爆。虽然关于大模型的发展与应用还有很多的争论，但可以肯定的是，大模型能力已经成为了接下来人工智能发展的基础。</p>
<p>和以前的小模型相比，大模型对大规模的分布式并行训练有更强的诉求。</p>
<p>这一方面是因为模型本身非常大。受制于今天的 GPU 显存限制，我们不得不把一个模型分拆到很多个 GPU 上来存储。比如说，百度的文心大模型有 2600 亿个参数，但是实际上一个 80G 显存的 A800，算上训练中间的计算状态，也只能存放大概 10 亿-20 亿参数。那显然光是存放 2600 亿的模型本身，就需要一两百块 GPU。这已经是一个比较大的规模了。</p>
<p>另一方面，因为训练更多的参数需要更多的计算量，因此我们必须得引入更大规模的 GPU 来进行加速，所以我们需要的 GPU 又要有一个数量级的提升。</p>
<p>在百度我们根据一个任务的 GPU 卡数来命名训练的规模。比如百卡以下我们叫小规模，百卡到千卡我们叫中规模，千卡以上我们叫大规模，超过万卡我们则以超大规模进行命名。依照这个命名方式，我们可以说，千卡以上的大规模并行训练是大模型成功的基础。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8b075997eeb63b9cb4040f95e3db72f0_1440w.webp">​</p>
<p>分布式并行训练有多种策略，我们这里列举出常用的三种。</p></div><a class="more" href="/article/%E5%A4%A7%E8%A7%84%E6%A8%A1AI%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5.html#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/article/GPT%E5%92%8CBERT%E7%9A%84%E5%B7%AE%E5%88%AB.html">GPT和BERT的差别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-12-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AI%E5%B7%A5%E7%A8%8B/">AI工程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/">大模型</a></span><div class="content"><h2 id="NLP的技术原理"><a href="#NLP的技术原理" class="headerlink" title="NLP的技术原理"></a><strong>NLP的技术原理</strong></h2><p>首先，我们要弄明白，NLP任务（自然语言处理，AI的一个技术领域，即文本类的AI任务）的核心逻辑是一个“猜概率”的游戏。</p>
<p>比如说，“我今天被我朋友___”，经过大量的数据训练后，AI预测空格出会出现的最高概率的词是“放鸽子了”，那么CPU就会被填到这个空格中，从而答案产生——“我今天被我朋友放鸽子了”</p>
<p>虽然非常不可思议，但事实就是这样，现阶段所有的NLP任务，都不意味着机器真正理解这个世界，他只是在玩文字游戏，进行一次又一次的概率解谜，本质上和我们玩报纸上的填字游戏是一个逻辑。只是我们靠知识和智慧，AI靠概率计算。</p>
<p>在近几年的<a href="https://link.zhihu.com/?target=https://cloud.tencent.com/product/nlp?from=10680">自然语言处理</a>领域中，BERT和GPT是两个引起广泛关注的语言模型。特别是在<a href="https://link.zhihu.com/?target=https://beta.openai.com/docs/model-index-for-researchers">GPT3.5</a>的基础上进行微调的<a href="https://link.zhihu.com/?target=https://openai.com/blog/chatgpt/">chatGPT</a>，持续出圈和火爆。chatGPT的火爆表明了预训练语言模型在自然语言处理领域具有巨大的潜力，并且在提高自然语言理解和生成能力方面取得了显著的进展。这可能会带来更多的应用和更广泛的接受。</p>
<p>BERT和GPT也都是基于预训练语言模型的思想，通过大量的语料训练而得到的高效率的语言模型。为了帮助大家更好的理解和选择不同的技术和模型，本文将着重比较BERT和GPT这两个语言模型之间的区别，为大家提供一个全面的认识。</p></div><a class="more" href="/article/GPT%E5%92%8CBERT%E7%9A%84%E5%B7%AE%E5%88%AB.html#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/article/%E5%A2%A8%E8%8F%B2%E5%AE%9A%E5%BE%8B&amp;%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B.html">墨菲定律&amp;康威定律</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1/">设计</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F/">系统</a></span><div class="content"><p><strong>在设计系统时，应该多考虑 墨菲定律：</strong></p>
<ul>
<li>任何事物都没有表面看起来那么简单。</li>
<li>所有的事都会比你预计的时间长。</li>
<li>可能出错的事总会出错。</li>
<li>如果你担心某种情况发生，那么他就更有可能发生。</li>
</ul>
<p><strong>在划分系统时，应该多考虑 康威定律：</strong></p>
<ul>
<li>系统架构是公司组织架构的反映。</li>
<li>应该按照业务闭环进行系统拆分／组织架构划分，实现闭环／高内聚／低耦合，减少沟通成本。</li>
<li>如果沟通出现问题，那么应该考虑进行系统和组织架构的调整。</li>
<li>在合适时机进行系统拆分，不要一开始就把系统／服务拆的非常细，虽然闭环，但是每个人维护的系统多，维护成本高。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/article/%E7%A0%94%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%E8%AE%BA.html">研发工作方法论</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a></span><div class="content"><p>copy from: <a target="_blank" rel="noopener" href="https://www.zybuluo.com/TryLoveCatch/note/1809593">https://www.zybuluo.com/TryLoveCatch/note/1809593</a></p>
<h2 id="研发工程师的基本功"><a href="#研发工程师的基本功" class="headerlink" title="研发工程师的基本功"></a>研发工程师的基本功</h2><ol>
<li>需求的交付能力；</li>
<li>系统的设计与架构能力；</li>
<li>行业对标与演化改进能力；</li>
</ol>
<p>想要系统化的提升基本功，首先要全面的对我们所接触到的技术要素做分解，站在全局进行思考。</p>
<h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><ul>
<li>为什么要做？<br>以客户为中心，从业务角度出发，业务最关心什么，我们不做会不会影响业务的核心指标</li>
<li>为什么现在做？<br>时间上 dead line</li>
<li>为什么是我们做？</li>
<li>怎么做<br>拆解</li>
</ul>
<p>一个规划应该主要分为：</p>
<ul>
<li>背景<br>业务理解，内部现状、业务影响、外部变化、背景总结</li>
<li>目标<br>根据背景要能推出来目标，也可分短期和长期目标，或者业务目标和技术目标，或者定性目标和定量目标</li>
<li>方案<br>方案是要解决背景中遇到的问题</li>
<li>指标<br>如果衡量结果的好坏呢</li>
<li>规划<br>具体的方案拆解，子任务拆解，具体到人和时间，每一个子任务应该是里程碑</li>
<li>风险以及应对<br>技术风险、资源风险、质量风险等或者业务维度（抓重点解决核心问题）、技术维度（难度）、组织维度（资源不足）、流程维度</li>
</ul>
<h2 id="技术要素拆分法（BeafQPS）"><a href="#技术要素拆分法（BeafQPS）" class="headerlink" title="技术要素拆分法（BeafQPS）"></a>技术要素拆分法（BeafQPS）</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol>
<li>行业对标 Benchmark</li>
<li>效率 Efficiency</li>
<li>架构 Architecture</li>
<li>功能 Feature</li>
<li>质量 Quality</li>
<li>性能 Performance</li>
<li>安全 Security</li>
</ol></div><a class="more" href="/article/%E7%A0%94%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%E8%AE%BA.html#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/article/%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6.html">监控告警</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%9B%91%E6%8E%A7/">监控</a></span><div class="content"><h1 id="1-监控"><a href="#1-监控" class="headerlink" title="1.监控"></a>1.监控</h1><h3 id="1-1-监控的目的"><a href="#1-1-监控的目的" class="headerlink" title="1.1 监控的目的"></a>1.1 监控的目的</h3><ul>
<li>了解业务量级增长</li>
<li>感知系统健康度</li>
<li>告警 -&gt; 及时发现问题</li>
</ul>
<p>可用性量化：  MTTF， MTTR，  SLA，  SLO</p>
<h3 id="1-2-好的监控体系应该做到哪些？"><a href="#1-2-好的监控体系应该做到哪些？" class="headerlink" title="1.2 好的监控体系应该做到哪些？"></a>1.2 好的监控体系应该做到哪些？</h3><ul>
<li>指标全面，但不冗余.</li>
<li>报警敏感，但不误报</li>
<li>自动发现问题，以及分析原因</li>
</ul>
<h3 id="1-3-监控指标"><a href="#1-3-监控指标" class="headerlink" title="1.3 监控指标"></a>1.3 监控指标</h3><p><strong>USE</strong>  (<strong>U</strong>tilization <strong>S</strong>aturation and <strong>E</strong>rrors）：  将注意力集中在处理工作负载的资源上。目标是了解这些资源在存在负载时的行为方式。</p>
<ul>
<li>使用率，表示资源用于服务的时间或容量百分比。100% 的使用率，表示容量已经用尽或者全部时间都用于服务。</li>
<li>饱和度，表示资源的繁忙程度，通常与等待队列的长度相关。100% 的饱和度，表示资源无法接受更多的请求。</li>
<li>错误数表示发生错误的事件个数。错误数越多，表明系统的问题越严重。</li>
</ul>
<p><strong>RED</strong>（<strong>R</strong>equest Throughput，<strong>E</strong>rror Rate, <strong>D</strong>uration Time）:    它是由资源提供服务的工作负载行为的外部可见视图</p>
<p><strong>四个黄金信号</strong>:  延迟（Latency），流量（Traffic），错误（Errors）和 饱和度（Saturation）</p></div><a class="more" href="/article/%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6.html#more">Read more</a><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://hexo-1256892004.cos.ap-beijing.myqcloud.com/page/top.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2024 By weibingo</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.0"></script><script src="/js/fancybox.js?version=1.8.0"></script><script src="/js/sidebar.js?version=1.8.0"></script><script src="/js/copy.js?version=1.8.0"></script><script src="/js/fireworks.js?version=1.8.0"></script><script src="/js/transition.js?version=1.8.0"></script><script src="/js/scroll.js?version=1.8.0"></script><script src="/js/head.js?version=1.8.0"></script><script src="/js/search/algolia.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>